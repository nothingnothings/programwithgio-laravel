





<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
        // * THIS IS HOW WE CAN ADD ADDITIONAL ROUTES, WITHOUT CLOGGING 'web.php'...
        then: function () {
            Route::prefix('transactions')
                ->name('transactions.')
                ->group(base_path('routes/transactions.php'));
        }
    )
    ->withMiddleware(function (Middleware $middleware) {
        //
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();















COMO VC PODE VER, DENTRO DE 'withMiddleware()',



UMA CLOSURE ESTÁ SENDO PASSADA,


E É EXATAMENTE NESSE LOCAL QUE 

DEFINIREMOS 

OS MIDDLEWARES A SEREM USADOS,

OS CUSTOM MIDDLEWARES...













-> ANTES DE DEFINIRMOS 1 CUSTOM MIDDLEWARE,

DEVEMOS INSPECIONAR ESSE METHOD...









--> OK... AGORA FALAREMOS SOBRE MIDDLEWARES...




É UM CONCEITO BEM IMPORTANTE...






ELE PODE PARECER COMPLEXO, MAS É BEM STRAIGHTFORWARD...
















-> PENSE NOS MIDDLEWARES COMO 1 SÉRIE DE FILTROS/LAYERS 


QUE DEVEM SER ATRAVESSADOS, PELOS REQUESTS, ANTES DE 

CHEGAR AO SEU APP....









-> ELES TIPICAMENTE SÃO POSICIONADOS ENTRE OS REQUESTS E OS CONTROLLERS,

PERMITINDO QUE VC:


1) INSPECIONE 

2) MODIFY 

3) STOP 



OS REQUESTS,


COM BASE EM CRITÉRIOS ESPECÍFICOS...










--> MTOS FRAMEWORKS, INCLUSIVE O LARAVEL,

    POSSUEM SUPORTE A MIDDLEWARES OUT OF THE BOX..






-> O LARAVEL JÁ TEM MIDDLEWARES APLICADOS POR DEFAULT,

    QUE USA NOS SEUS REQUESTS,



    E QUE ESTÃO 'HIDDEN' DE SEUS OLHOS...












-> O PROFESSOR QUER NOS MOSTRAR 

    ALGUNS DELES, PARA QUE ENTENDAMOS COMO ISSO FUNCIONA...












-> O PROFESSOR TEM O CÓDIGO DE 'app.php',


    EM QUE TEMOS O METHOD DE 'withMiddleware()':







    /**
     * Register the global middleware, middleware groups, and middleware aliases for the application.
     *
     * @param  callable|null  $callback
     * @return $this
     */
    public function withMiddleware(?callable $callback = null)
    {
        $this->app->afterResolving(HttpKernel::class, function ($kernel) use ($callback) {
            $middleware = (new Middleware)
                ->redirectGuestsTo(fn () => route('login'));

            if (! is_null($callback)) {
                $callback($middleware);
            }

            $this->pageMiddleware = $middleware->getPageMiddleware();
            $kernel->setGlobalMiddleware($middleware->getGlobalMiddleware());
            $kernel->setMiddlewareGroups($middleware->getMiddlewareGroups());
            $kernel->setMiddlewareAliases($middleware->getMiddlewareAliases());

            if ($priorities = $middleware->getMiddlewarePriority()) {
                $kernel->setMiddlewarePriority($priorities);
            }

            if ($priorityAppends = $middleware->getMiddlewarePriorityAppends()) {
                foreach ($priorityAppends as $newMiddleware => $after) {
                    $kernel->addToMiddlewarePriorityAfter($after, $newMiddleware);
                }
            }

            if ($priorityPrepends = $middleware->getMiddlewarePriorityPrepends()) {
                foreach ($priorityPrepends as $newMiddleware => $before) {
                    $kernel->addToMiddlewarePriorityBefore($before, $newMiddleware);
                }
            }
        });

        return $this;
    }













QUER DIZER QUE O PROPÓSITO DESSE METHOD É:




    /**
     * Register the global middleware, middleware groups, and middleware aliases for the application.
     *









    
COMO VC PODE VER,



DEPOIS DO 'HttpKernel'

ser 'resolved',




O LARAVEL SETTA ALGUNS MIDDLEWARES...






COM ESTA PARTE:






            $this->pageMiddleware = $middleware->getPageMiddleware();
            $kernel->setGlobalMiddleware($middleware->getGlobalMiddleware());
            $kernel->setMiddlewareGroups($middleware->getMiddlewareGroups());
            $kernel->setMiddlewareAliases($middleware->getMiddlewareAliases());












    


É BEM SIMPLES ENTENDER O QUE ESSE METHOD DE 'withMiddleware'


faz:








ELE REGISTRA OS GLOBAL MIDDLEWARES E MIDDLEWARE GROUPS...









É CLARO QUE ESSE METHOD FAZ ALGUMAS OUTRAS COISAS,



COMO 'redirectGuestsTo()'



e algo com a 'priorities'... mas, mesmo assim,

vc 


pode entender o que esse method faz...

















EXPLICAÇÃO:



''EM LARAVEL, VC É CAPAZ DE DEFINIR MIDDLEWARES GLOBALMENTE...
    ISSO SIGNIFICA QUE TODO HTTP REQUEST QUE VAI POR DENTRO 
    DE SEU APP 

    VAI TER DE PASSAR POR SEUS MIDDLEWARES'...











--> SE CLICAMOS EM 'getGlobalMiddleware',


PODEMOS VER A LISTA DE GLOBAL MIDDLEWARES DEFAULT:





        $middleware = $this->global ?: array_values(array_filter([
            \Illuminate\Foundation\Http\Middleware\InvokeDeferredCallbacks::class,
            $this->trustHosts ? \Illuminate\Http\Middleware\TrustHosts::class : null,
            \Illuminate\Http\Middleware\TrustProxies::class,
            \Illuminate\Http\Middleware\HandleCors::class,
            \Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance::class,
            \Illuminate\Http\Middleware\ValidatePostSize::class,
            \Illuminate\Foundation\Http\Middleware\TrimStrings::class,
            \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
        ]));








CERTO... MAS O QUE SÃO?




            \Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance::class,







-> ESSE IMPEDE REQUESTS DE ENTRAR NO APP,

    QUANDO VC USA O COMMAND ARTISAN DE 'down'...





--> TEMOS MIDDLEWARES, TAMBÉM, PARA:



1) VALIDATE O TAMANHO DO POST REQUEST 



2) TRIM STRINGS 



E ETC...

















OK... MAS COMO PODEMOS REGISTRAR NOVOS CUSTOM MIDDLEWARES,

DE MODO QUE 

ELES CONSIGAM FAZER PARTE DESSA LISTA DE MIDDLEWARES?










a maneira mais recomendada é ler os docs na page do laravel...








--> ENTRETANTO, PODEMOS APRENDER A FAZER ISSO SEM 

    LER A DOCUMENTATION... SE VC LER O SOURCE CODE...














--> SE INSPECIONAMOS OS METHOD CALLS DE 'getGlobalMiddleware()',


temos 1 trecho assim:








        return array_values(array_filter(
            array_diff(
                array_unique(array_merge($this->prepends, $middleware, $this->appends)),
                $this->removals
            )))






    basicamente,



    ELE SETTA OS MIDDLEWARES AQUI,

    por meio de 'array_merge'...








VC PERCEBE QUE ELE TEM 'prepends', 'middleware' e 'appends'...









-> OU SEJA,
 

 ESSA PARTE JÁ NOS DIZ QUE 



 ''SE QUEREMOS ADICIONAR NOSSOS PRÓPRIOS MIDDLEWARES,

 DEVEMOS ADICIONÁ-LOS   __ OU __ NA LIST DE PREPENDS,

 OU NA LIST DE APPENDS'....














-> COMO O CÓDIGO DE 'Middleware.php'


É DO PRÓPRIO 

FRAMEWORK,

NÃO PODEMOS FAZER ALTERAÇÕES A ELE...












--> O LOCAL EM QUE PODEMOS FAZER MODIFICAÇÕES É 'app.php'...









--> QUEREMOS ADICIONAR NOSSO MIDDLEWARE OU EM 'prepends'

ou 'appends',


para que sejam considerados junto dos middlewares que o laravel tem por default...








SE CLICAMOS EM 'prepends',



percebemos que é uma PROTECTED PROPERTY... ISSO PROVAVELMENTE QUER DIZER QUE 
TEMOS 1 PUBLIC SETTER PROPERTY 

QUE FAZ O SET DESSE NEGÓCIO...












-> Os methods de 'prepend' e 'append' 



exigem/aceitam 




OU ARRAYS, OU STRINGS...







--> A BOA NOTÍCIA É QUE NÓS REALMENTE TEMOS ACESSO A ESSES METHODS...


MAS COMO FAZEMOS O CALL DELES?














--> SE VOLTAMOS AO 'app.php',


PERCEBEMOS QUE TEMOS O METHOD CALL DE 

'->withMiddleware'...








TIPO ASSIM:







<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
        // * THIS IS HOW WE CAN ADD ADDITIONAL ROUTES, WITHOUT CLOGGING 'web.php'...
        then: function () {
            Route::prefix('transactions')
                ->name('transactions.')
                ->group(base_path('routes/transactions.php'));
        }
    )
    ->withMiddleware(function (Middleware $middleware) {
        //
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();












COMO VC PODE VER,


TEMOS ACESSO à INSTANCE DE '$middleware'...










-> PROVAVELMENTE TEMOS QUE CHAMAR ALGO COMO 

$middleware->prepends(YourMiddleware::class)...















--> É POR ISSO QUE, ALI,


DEVEMOS CHAMAR OS METHODS,

TIPO ASSIM:










<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
        // * THIS IS HOW WE CAN ADD ADDITIONAL ROUTES, WITHOUT CLOGGING 'web.php'...
        then: function () {
            Route::prefix('transactions')
                ->name('transactions.')
                ->group(base_path('routes/transactions.php'));
        }
    )
    ->withMiddleware(function (Middleware $middleware) {

        $middleware->append(); // * THIS APPENDS YOUR CUSTOM MIDDLEWARE TO THE END OF THE GLOBAL MIDDLEWARE STACK.
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();



















CERTO...






MAS ANTES DE ADICIONARMOS 1 MIDDLEWARE,

PRECISAMOS CRIÁ-LO...






''DIGAMOS QUE QUEREMOS 1 MIDDLEWARE PARA 

    ''__IDENTIFY A REQUEST BY ID'', 

    FOR TRACKING PURPOSES''...








-> àS VEZES VC VAI QUERER TRACKEAR  1 REQUEST INTEIRO...
    E, AÍ, SE O REQUEST TEM 1 UNIQUE ID,

    FICA MAIS FÁCIL ENCONTRAR ESSE REQUEST NOS LOGS,

    SE VC TIVER O ID...








--> PODEMOS CHAMAR ESSE MIDDLEWARE DE ALGO COMO 'assignRequestIdMiddleware'...








-> PARA CRIAR ESSE MIDDLEWARE, PODEMOS USAR O ARTISAN COMMAND RESPECTIVO,


QUE É 


php artisan make:middleware








FICOU TIPO ASSIM:










<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        return $next($request);
    }
}











EU JÁ CRIEI 1 MIDDLEWARE ANTES,


A SINTAXE É TIPO ASSIM:














<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Illuminate\View\View;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): View
    {
        return view('auth.register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function handle(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'lowercase', 'email', 'max:255', 'unique:'.User::class],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard', absolute: false));
    }
}
  













ELES POSSUEM APENAS 1 ÚNICO METHOD, DE 'handle()',



QUE 


VAI 



PROCESSAR NOSSOS HTTP REQUESTS...







--> podemos usar isso para handlar o redirect do user,

em casos de falta de auth...







--> NO METHOD DE 'handle()',

temos sempre 2 parameters,



'request' e 'closure'...








-> REQUEST É O CURRENT REQUEST...





-> 'CLOSURE' -> é o '$next',

                que serve para PASSAR O REQUEST AO PRÓXIMO MIDDLEWARE/ELO 

                NA CHAIN DO APP,

                PARA FAZER O GENERATE DA RESPONSE...














--> O MIDDLEWARE PEGA O REQUEST, FAZ ALGO COM O REQUEST, E AÍ PASSA-O ADIANTE 
NA CHAIN...








NO CASO, O NEGÓCIO ESTÁ ASSIM:










<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        return $next($request);
    }
}












MAS VC PODE ESCREVER ALGO ASSIM:





    public function handle(Request $request, Closure $next): Response
    {
        $response = $next($request);

        // Your middleware logic

        return $response;
    }










SE VC ESCREVER ALGO ASSIM,
A LÓGICA DE SEU MIDDLEWARE SERÁ APLICADA __ DEPOIS __ 


DA RESPONSE SER GENERATED... 





E VC PODE FAZER DOS 2 JEITOS:





1) PODE RODAR A LÓGICA _ ANTES__ DO GENERATE DA RESPONSE 



2) PODE RODAR A LÓGICA __ DEPOIS __ DO GENERATE DA RESPONSE:








    public function handle(Request $request, Closure $next): Response
    {
        // Your middleware logic 

        $response = $next($request);

        // Your middleware logic

        return $response;
    }










OK... MAS, NO NOSSO CASO ATUAL,

QUEREMOS 


''ASSIGN THE ID TO THE REQUEST __ BEFORE_ 
    WE __ PROCESS THE REQUEST''...









--> É POR ISSO QUE PRECISAMOS COLOCAR A LÓGICA __ ANTES__...










-> QUEREMOS GERAR O UNIQUE ID PARA O REQUEST...



--> PARA ISSO, PODEMOS USAR A PACKAGE Uuid..









--> temos o helper method do laravel para gerar unique ids,

com este código:








<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Uid\Uuid;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Your middleware logic
        $requestId = (string) Uuid::v4();

        $response = $next($request);

        // Your middleware logic

        return $response;
    }
}












DEPOIS DISSO, QUEREMOS ASSIGNAR O VALUE DE ESSE ID AO 'REQUEST HEADER'...








--> PARA SETTAR 1 HEADER NO NOSSO REQUEST,


 
PODEMOS USAR O METHOD 



DE 'set()',


no object 'headers', dentro do request,

tipo assim:










<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Uid\Uuid;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Your middleware logic (Before generating the response)
        $requestId = (string) Uuid::v4();

        $request->headers->set('X-Request-Id', $requestId);

        $response = $next($request);

        // Your middleware logic (After generating the response)
        return $response;
    }
}










EX:








<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Uid\Uuid;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Your middleware logic (Before generating the response) goes here:
        $requestId = (string) Uuid::v4();

        $request->headers->set('X-Request-Id', $requestId);

        $response = $next($request);

        //  Your middleware logic (After generating the response) goes here:

        return $response;
    }
}














MAS DEPOIS DE PROCESSAR O REQUEST,



VAMOS QUERER ADICIONAR O 'requestId'


AOS HEADERS DA RESPONSE, TAMBÉM,


POR ISSO ESCREVEMOS ASSIM:







<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Uid\Uuid;

class AssignRequestIdMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Your middleware logic (Before generating the response) goes here:
        $requestId = (string) Uuid::v4();

        $request->headers->set('X-Request-Id', $requestId);

        $response = $next($request);

        //  Your middleware logic (After generating the response) goes here:

        $response->headers->set('X-Request-Id', $requestId);

        return $response;
    }
}
















podemos adicionar 1 check para 

VERIFICAR SE O HEADER JÁ TINHA SIDO SETTADO ANTES, POR MEIO DO 
NGINX...






BASTA ESCREVER TIPO ASSIM:







$requestId = $request->headers->get('X-Request-Id');


if(!$requestId) {

}











        // Your middleware logic (Before generating the response) goes here:
        $requestId = $request->headers->get('X-Request-Id');

        if (!$requestId) {
            $requestId = (string) Uuid::v4();

            $request->headers->set('X-Request-Id', $requestId);
        }










certo...



faz sentido...



AGORA DEVEMOS TENTAR REGISTRAR ESSE MIDDLEWARE...











em 'app.php',

PODEMOS ESCREVER ASSIM:









<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
        // * THIS IS HOW WE CAN ADD ADDITIONAL ROUTES, WITHOUT CLOGGING 'web.php':
        // then: function () {
        //     Route::prefix('transactions')
        //         ->name('transactions.')
        //         ->group(base_path('routes/transactions.php'));
        // }
    )
    ->withMiddleware(function (Middleware $middleware) {
        $middleware->append(App\Http\Middleware\AssignRequestIdMiddleware::class);
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();










TIPO ASSIM:






    ->withMiddleware(function (Middleware $middleware) {
        $middleware->append(App\Http\Middleware\AssignRequestIdMiddleware::class);
    })











PODEMOS CHECAR SE ISSO FUNCIONOU,


LÁ NA ROUTE DE TRANSACTIONS,


tipo assim:










<?php

namespace App\Http\Controllers;

use App\Models\Transaction;
use Illuminate\Http\Request;

class TransactionController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(Request $request)
    {
        echo $request->headers->get('X-Request-Id'); // this will return the value of the header 'X-Request-Id'
        echo route('transactions.home') . '<br />'; // this will return the built url for the route 'transactions.home', in this case, 'localhost/transactions'

        echo route('transaction', ['transactionId' => 55]) . '<br />'; // this will return the built url for the route 'transactions.show', in this case, 'localhost/transactions/55'


        // * THIS WILL REDIRECT THE USER to the specified named route.
        to_route('transactions.create'); // this will return the built url for the route 'transactions.home', in this case, 'localhost/transactions'



        return view('transactions.index');
    }















mas talvez vc queira ganhar acesso AO 'requestId'



''BETWEEN MIDDLEWARES''....








-> AÍ, SE VC QUISER FAZER ISSO,


VC TERIA DE USAR 'prepend()', 

EM VEZ DE 'append()',


TIPO ASSIM:








    ->withMiddleware(function (Middleware $middleware) {

        // $middleware->prepend(); // * THIS PREPENDS YOUR CUSTOM MIDDLEWARE TO THE BEGINNING OF THE GLOBAL MIDDLEWARE STACK.
        // $middleware->append(); // * THIS APPENDS YOUR CUSTOM MIDDLEWARE TO THE END OF THE GLOBAL MIDDLEWARE STACK.

        $middleware->prepend(App\Http\Middleware\AssignRequestIdMiddleware::class); // * THIS PREPENDS YOUR CUSTOM MIDDLEWARE TO THE BEGINNING OF THE GLOBAL MIDDLEWARE STACK.
        $middleware->append(App\Http\Middleware\AssignRequestIdMiddleware::class);
    })















--> ALÉM DA POSSIBILIDADE DE ASSIGN OS MIDDLEWARE GLOBALMENTE,

VC PODE TAMBÉM ADICIONÁ-LOS 


A ROUTES ESPECÍFICAS...







--> também é possível 

    MANIPULAR OS MIDDLEWARES GLOBAIS,

    PARA LIGAR/DESLIGAR MIDDLEWARES GLOBAIS ESPECÍFICOS....

    O PROFESSOR N RECOMENDA FAZER ISSO,

    MAS ELE APONTA QUE É POSSÍVEL,

    E É BOM TER ESSA FLEXIBILIADE...








--> ISSO PODE SER VISTO COM A PROPRIEDADE '$this->global',

dentro de 'Middleware.php'...








--> PARA DESABILITAR OS GLOBAL MIDDLEWARES,


PODEMOS 





CHAMAR O METHOD DE '->use()',



DENTRO DO METHOD 'withMiddleware()',

em app.php...





TIPO ASSIM:










<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {

         $middleware->use([]); // This is used if you want to disable the global middlewares.










ENTAO O PROFESSOR NOS MOSTRA 1 EXEMPLO DE COMO PODEMOS DEFINIR MIDDLEWARES PARA ROUTES 
ESPECÍFICAS...





DIGAMOS QUE QUEREMOS TER 1 ROUTE QUE PODE SER ACESSADA APENAS POR ADMINS..











-> PARA ISSO,
PODEMOS ESCREVER TIPO ASSIM:







Route::get('/administration', function() {
    return 'Some Secret Admin Page';
})






EX:







// Example of route-specific middleware (auth guards).
Route::get('/administration', function () {
    return 'Some Secret Admin Page';
});








AGORA SUPONHA QUE TEMOS 1 USER AUTENTICADO...








--> PARA BLOQUEAR ESSA ROUTE DE UNAUTH USERS,


PODEMOS ESCREVER ASSIM:







// Example of route-specific middleware (auth guards).
Route::get('/administration', function () {
    return 'Some Secret Admin Page';
})->middleware();











PODEMOS PASSAR OU 1 ÚNICO MIDDLEWARE, OU 1 LISTA DE MIDDLEWRES, AQUI...












--> PODE SER 1 MIDDLEWARE COMO 


'CheckUserRole'...





CRIAMOS ESSE MIDDLEWARE COM php artisan make:middleware 















OK... ASSUMIMOS QUE O USER ESTÁ LOGGED IN,

E AÍ 


ARMAZENAMOS A INFO EM 1 VARIABLE,


COMO '''


$user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];











EX:











<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class CheckUserRole
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];


        return $next($request);
    }
}














AÍ PODEMOS ADICIONAR ISSO COMO HEADER NO REQUEST...






--> MAS, ANTES DISSO, CHECAMOS SE O USER ROLE É 'admin',


e aí 


RETORNAR o '$next($request)',




PARA QUE O REQUEST PROSSIGA NORMALMENTE..



CASO CONTRÁRIO, QUEREMOS GERAR 1 NOVA RESPONSE, COM 1 
NOVO STATUS,

COMO '404' OU '403' (unauthorized)...









tipo assim:





<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class CheckUserRole
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];

        if ($user['role'] === 'admin') {
            return $next($request);
        }

        return response(status: 404);
    }
}














CERTO...





ESSE É UM AUTH BÁSICO...










REDIRECIONAR O USER À HOME PAGE É A COMMON WAY 


DE TER 1 AUTH GUARD NO APP...








--> MAS O PROFESSOR NÃO GOSTA DESSE APPROACH POR ALGUMAS RAZOES:




1) SE O USER TENTOU ENTRAR EM 1 PAGE A QUE ELE N TEM AUTORIZAÇÃO 
    E É REDIRECIONADO, O USER PODE 

    ADIVINHAR QUE ''BEM, PARECE QUE ESSA PAGE EXISTE,  MAS ESTOU SENDO REDIRECIONADO 
                        POR CONTA DA FALTA DE AUTH... POSSO EXPLOITAR ISSO...''


        e esse 'guess' pode não ser ok, dependendo do app...

        E VC ENVIAR UM STATUS CODE DE '403' BASICAMENTE 
        DIZ 

        ''HEY, ESSA PÁGINA EXISTE, MAS É UMA __ HIDDEN PAGE,
        QUE APENAS CERTOS USERS PODEM ACESSAR''....



        --> JÁ SE VC USAR UM STATUS CODE DE 404,
            ISSO DIZ AO USER QUE A PAGE NÃO EXISTE,
            O QUE É MAIS SEGURO, SE VC CONSIDERAR 
            O EXPOSTO ACIMA...





--> AQUI, O PROFESSOR FAZ 

O GENERATE DE UMA RESPONSE COM STATUS DE 404... (com 'response(status:404)'),

mas

vc também poderia fazer throw 

da exception de 'HttpNotFoundException',

do laravel,


que é mais 'smooth'...





--> com a exception, o exception handler do 
    laravel faz handle da página de 404,

    o que acaba deixando mais SMOOTH o error handling...








--> vc pode fazer isso OU COM:


throw new HttpException(404, 'Custom Not Found Message');




OU COM:


        abort(404, 'This page does not exist.');











FICOU TIPO ASSIM:









<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

// Basic check for user authorization in your app.
class CheckUserRole
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];

        if ($user['role'] === 'admin') {
            return $next($request);
        }

        // ! This way is uglier than the NotFoundException approach, because it doesn't use laravel's exception handler to render the 404 page.
        // return response(status: 404); // this is better than saying '403', because then we don't give the user the info that the page that he was blocked from exists (we only say: 'this page does not exist', which is a lie, but is fine)

        abort(404, 'This page does not exist.'); // * this is essentially the same as a throw new NotFoundHttpException(404, 'This page does not exist.')
    }
}













MAIS TARDE VEREMOS PROPER AUTHENTICATION E USER ROLE CHECKING...





 







 --> o 'abort()'


 PEDE QUE VC PASSE O STATUS CODE da sua response...










 --> O CÓDIGO DE ABORT É BEM SIMPLES:




    public function abort($code, $message = '', array $headers = [])
    {
        if ($code == 404) {
            throw new NotFoundHttpException($message, null, 0, $headers);
        }

        throw new HttpException($code, $message, null, $headers);
    }














CERTO... COM ISSO, FICAMOS COM A PAGE DE 404 COMUM DO LARAVEL...













OK... MAS AGORA, NO CASO,

E SE QUEREMOS TER 

MÚLTIPLAS ROUTES,


ADMIN-SPECIFIC?











-> É CLARO QUE VC PODERIA ADICIONAR ESSE MIDDLEWARE A CADA UMA DAS ROUTES,


TIPO ASSIM:





// Example of route-specific middleware (auth guards).
Route::get('/administration', function () {
    return 'Some Secret Admin Page';
})->middleware(CheckUserRole::class); // * this is the middleware that checks if the user is an admin.













-> MAS SERIA 1 SACO TER DE ADICIONAR ESSE MIDDLEWARE DE '->middleware(CheckUserRole:class)'



EM CADA 1 DE SUAS ADMIN-SPECIFIC ROUTES...










-> É NESSES CASOS QUE 'Route::group()'


É BEM ÚTIL...








--> PARA DEMONSTRAR, ADICIONAMOS UMA NOVA ROUTE,

E AÍ AGRUPAMOS ISSO, COM 'Route::group()',

TIPO ASSIM:








Route::group(
    function () {
        Route::get('/administration', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/administration/other', function () {
            return 'Another Secret Admin Page';
        });
    }
)->middleware(CheckUserRole::class);













PODEMOS, AINDA, USAR 'Route::prefix()' 

com isso 


tudo, para ficar ainda mais chique...





EX:






// * Even better usage of group, to have a single call of '->middleware()', and then 'prefix', to implicitly set 'administration' prefix)
Route::prefix('/administration')->middleware(CheckUserRole::class)->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);











CERTO... 


E ISSO REALMENTE FUNCIONA...









--> HÁ OUTRA MANEIRA DE APLICAR O MIDDLEWARE A 1 GRUPO DE ROUTES...










--> A OUTRA MANEIRA É ESCREVER ASSIM:


Route::middleware(CheckUserRole::class)->group(
    function() {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);











ESSA SINTAXE DEVE SER UTILIZADA SE VC NÃO QUER ADICIONAR 
1 PREFIX A SUAS ROUTES...












CERTO...




faz sentido...






também pode escrever o prefix assim:





Route::middleware(CheckUserRole::class)->prefix('/administration')->group(
    function() {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);




O ÚNICO DETALHE, AQUI, É QUE 


o 'group' de routes deve sempre vir DEPOIS DO 'middleware', 'prefix' e coisas 
do gênero...












CÓDIGO FINAL:










// * Example of route-specific middleware (auth guards).
// Route::get('/administration', function () {
//     return 'Some Secret Admin Page';
// })->middleware(CheckUserRole::class); // * this is the middleware that checks if the user is an admin.

// * Better (usage of group, to have a single call of '->middleware()')
// Route::group(
//     function () {
//         Route::get('/administration', function () {
//             return 'Some Secret Admin Page';
//         });
//         Route::get('/administration/other', function () {
//             return 'Another Secret Admin Page';
//         });
//     }
// )->middleware(CheckUserRole::class);

// * Even better usage of group, to have a single call of '->middleware()', and then 'prefix', to implicitly set 'administration' prefix)
Route::prefix('/administration')->middleware(CheckUserRole::class)->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);

// * Other way to write the code seen above:
// Route::middleware(CheckUserRole::class)->prefix('/administration')->group(
//     function () {
//         Route::get('/', function () {
//             return 'Some Secret Admin Page';
//         });
//         Route::get('/other', function () {
//             return 'Another Secret Admin Page';
//         });
//     }
// );


// * Use this syntax if you don't want to use a prefix segment in your routes
// Route::middleware(CheckUserRole::class)->group(
//     function () {
//         Route::get('/', function () {
//             return 'Some Secret Admin Page';
//         });
//         Route::get('/other', function () {
//             return 'Another Secret Admin Page';
//         });
//     }
// );
























MAS DIGAMOS QUE TEMOS MÚLTIPLOS MIDDLEWARES, EM VEZ DE 1 ÚNICO MIDDLEWARE..







-> NESSES CASOS,


ESCREVEMOS 1 ARRAY DE MIDDLEWARES DENTRO DE 'Route::middleware()',


TIPO ASSIM:







Route::prefix('/administration')->middleware([CheckUserRole::class, SomeOtherMiddleware::class])->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);












OK... MAS DIGAMOS QUE VC QUER IMPEDIR QUE 1 DESSES MIDDLEWARES 
SEJA APLICADO A ALGUMA DAS ROUTES DENTRO DE ESSE GROUP... COMO VC FARIA ISSO?













--> VC PODE FAZER ISSO, NO LARAVEL, PQ 
EXISTE UM METHOD CHAMADO DE '->withoutMiddleware()',


QUE VC PODE ADICIONAR A ROUTES INDIVIDUAIS...





TIPO ASSIM:








Route::prefix('/administration')->middleware([CheckUserRole::class, SomeOtherMiddleware::class])->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        })->withoutMiddleware(SomeOtherMiddleware::class);
    }
);









EX:







// * This is how you can:
// * 1) use multiple middlewares in a group of routes
// * 2) exclude a middleware from being applied to a route/some of the routes in the group, while being applied to all others.
Route::prefix('/administration')->middleware([CheckUserRole::class, SomeOtherMiddleware::class])->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        })->withoutMiddleware(SomeOtherMiddleware::class);
    }
);











-> vc também pode adicionar 'withoutMiddleware()' a groups inteiros,
    para exclude daquele group inteiro...
     







---> CERTO... AGORA DEVEMOS CONTINUAR...






--> O LARAVEL TEM ALGUNS DEFAULT MIDDLEWARE GROUPS,
    QUE JÁ SÃO APLICADOS A ALGUMAS ROUTES...









SE VOLTAMOS ATÉ A CLASS DE 'ApplicationBuilder.php',




TEMOS ESTE CÓDIGO:








    /**
     * Register the global middleware, middleware groups, and middleware aliases for the application.
     *
     * @param  callable|null  $callback
     * @return $this
     */
    public function withMiddleware(?callable $callback = null)
    {
        $this->app->afterResolving(HttpKernel::class, function ($kernel) use ($callback) {
            $middleware = (new Middleware)
                ->redirectGuestsTo(fn () => route('login'));

            if (! is_null($callback)) {
                $callback($middleware);
            }

            $this->pageMiddleware = $middleware->getPageMiddleware();
            $kernel->setGlobalMiddleware($middleware->getGlobalMiddleware());
            $kernel->setMiddlewareGroups($middleware->getMiddlewareGroups());
            $kernel->setMiddlewareAliases($middleware->getMiddlewareAliases());

            if ($priorities = $middleware->getMiddlewarePriority()) {
                $kernel->setMiddlewarePriority($priorities);
            }

            if ($priorityAppends = $middleware->getMiddlewarePriorityAppends()) {
                foreach ($priorityAppends as $newMiddleware => $after) {
                    $kernel->addToMiddlewarePriorityAfter($after, $newMiddleware);
                }
            }

            if ($priorityPrepends = $middleware->getMiddlewarePriorityPrepends()) {
                foreach ($priorityPrepends as $newMiddleware => $before) {
                    $kernel->addToMiddlewarePriorityBefore($before, $newMiddleware);
                }
            }
        });

        return $this;
    }
















temos a parte de 'getGlobalMiddleware()',




sim, mas temos também 'getMiddlewareGroups()'...









DENTRO DISSO, 

TEMOS ISTO:









    public function getGlobalMiddleware()
    {
        $middleware = $this->global ?: array_values(array_filter([
            \Illuminate\Foundation\Http\Middleware\InvokeDeferredCallbacks::class,
            $this->trustHosts ? \Illuminate\Http\Middleware\TrustHosts::class : null,
            \Illuminate\Http\Middleware\TrustProxies::class,
            \Illuminate\Http\Middleware\HandleCors::class,
            \Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance::class,
            \Illuminate\Http\Middleware\ValidatePostSize::class,
            \Illuminate\Foundation\Http\Middleware\TrimStrings::class,
            \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
        ]));

        $middleware = array_map(function ($middleware) {
            return $this->replacements[$middleware] ?? $middleware;
        }, $middleware);

        return array_values(array_filter(
            array_diff(
                array_unique(array_merge($this->prepends, $middleware, $this->appends)),
                $this->removals
            )
        ));
    }









COMO VC PODE VER, O LARAVEL TEM 2 MIDDLEWARE GROUPS,
DIFERENTES...












TEM 1 MIDDLEWARE GROUP PARA 'web',
e outro para 'api'...










web --> são middlewares que são aplicados 
        ao arquivo 'web.php'...



'api' --> são aplicados 
            À file de 'api.php'...




            --> NO NOSSO PROJETO, NÃO TEMOS  O ARQUIVO DE 'api.php',

            mas se tivéssemos, 



            esses seriam os middlewares aplicados ÀS routes dele...







--> BASICAMENTE, NOSSOS 
    WEB REQUESTS VÃO POR DENTRO 

    DESSES WEB MIDDLEWARES, ALÉM 

    DE IR POR DENTRO DOS 'GLOBAL' E 'CUSTOM' MIDDLEWARES










--> E VC PODE   
    FAZER APPEND/PREPEND/REPLACE dos

    MIDDLEWARES DESSES MIDDLEWARE GROUPS 

    DE 'web' e 'api',



    SE VC RODAR ESSES METHODS, LÁ DENTRO 

    DO METHOD 'withMiddleware()',

    lá no arquivo 'bootstrap>app.php'...






no nosso app.php, estamos com ESTE CÓDIGO:






<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        $middleware->prepend(App\Http\Middleware\AssignRequestIdMiddleware::class); // * THIS PREPENDS YOUR CUSTOM MIDDLEWARE TO THE BEGINNING OF THE GLOBAL MIDDLEWARE STACK.
        $middleware->append(App\Http\Middleware\AssignRequestIdMiddleware::class);
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();
















-> PARA FAZER ISSO, PARA EDITAR ESSES MIDDLEWARES DE 'web',


basta voce chamar 


'$middleware->web()',




TIPO ASSIM:






<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',

    )
    ->withMiddleware(function (Middleware $middleware) {
        
         $middleware->web(); // * arguments are arrays: prepend, append, remove, replace.

    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })->create();


















O METHOD DE '->web()', no caso, faz ISTO:


    public function web(array|string $append = [], array|string $prepend = [], array|string $remove = [], array $replace = [])
    {
        return $this->modifyGroup('web', $append, $prepend, $remove, $replace);
    }











--> ESSE METHOD TE DEIXA:


'append', 'prepend', 'remove' e 'replace'...



--> VC TAMBÉM PODE USAR '->api()',
    que faz a mesma coisa, mas com os middlewares 

    de 'api'...







--> CERTO... POR EXEMPLO, 
    SE DESEJAMOS ADICIONAR O MIDDLEWARE DE 'AssignRequestId'
    SOMENTE AOS WEB REQUESTS,



    ESCREVEMOS ASSIM:







    ->withMiddleware(function (Middleware $middleware) {

        $middleware->web(
            append: [AssignRequestIdMiddleware::class]
        );

    })






SE VC QUER USAR 'prepend',

é só usar 'prepend: xxxxx'...







E SE VC QUER SUBSTITUIR 1 DOS MIDDLEWARES, NO MIDDLEWARE GROUP DE 'web',


POR OUTRO MIDDLEWARE,





vc usa 


'replace:',




tipo 






replace: [EncryptCookies::class => YourEncryptCookiesMiddleware::class];









OU SEJA,

VC VAI PASSAR 1 KEY VALUE PAIR,

EM QUE A KEY É O 'OLD MIDDLEWARE',

E O VALUE É O __ NEW MIDDLEWARE...









-> OUTRA POSSIBILIDADE É 
'remove: ',





tipo assim:





        $middleware->web(
            // append: [AssignRequestIdMiddleware::class],
            // prepend: [AssignRequestIdMiddleware::class],
            // replace: [EncryptCookies::class => YourEncryptionMiddleware::class], // replace one of the default web middlewares
            // remove: [VerifyCsrfToken::class], // remove one of the default web middlewares
        );











--> VC TAMBÉM PODE FAZER APPEND DO SEU MIDDLEWARE EM 1 DOS MIDDLEWARE GROUPS DEFAULT,


COM O METHOD '$middleware->appendToGroup()',



ESCOLHENDO OU O GROUP 'api' ou o group 'web'...




EX:

$middleware->appendToGroup('web')




-> VC TAMBÉM PODE FAZER O PREPEND,
COM O METHOD '$middleware->prependToGroup()',



ESCOLHENDO OU O GROUP 'api' ou o group 'web'...




EX:



$middleware->prependToGroup('web')












--> VC TAMBÉM PODE USAR ESSES METHODS COM SEUS PRÓPRIOS MIDDLEWARES,

TIPO 


''

$middleware->prependToGroup([CheckUserRole::class, SomeOtherMiddleware::class]);

''








e os calls de '$middleware->web()' e '$middleware->api()'




FAZEM O CALL DE 'modifyGroup()',

que, por sua vez,

já se utiliza 

desse 'prependToGroup()' e 'appendToGroup()' para modificar os 


middleware groups default,

tipo assim:







    public function web(array|string $append = [], array|string $prepend = [], array|string $remove = [], array $replace = [])
    {
        return $this->modifyGroup('web', $append, $prepend, $remove, $replace);
    }




E ASSIM:






    protected function modifyGroup(string $group, array|string $append, array|string $prepend, array|string $remove, array $replace)
    {
        if (! empty($append)) {
            $this->appendToGroup($group, $append);
        }

        if (! empty($prepend)) {
            $this->prependToGroup($group, $prepend);
        }

        if (! empty($remove)) {
            $this->removeFromGroup($group, $remove);
        }

        if (! empty($replace)) {
            foreach ($replace as $search => $replace) {
                $this->replaceInGroup($group, $search, $replace);
            }
        }

        return $this;
    }







quer dizer que tudo dá na mesma...









HÁ TAMBÉM MANEIRAS DE:



1) DEFINE MIDDLEWARE ALIASES...



2) PASS PARAMETERS TO MIDDLEWARES...










--> PARA FAZER ALIAS DE 1 MIDDLEWARE,

VC PODE USAR O METHOD '->alias()',

    DENTRO DO METHOD DE '->withMiddleware()'










ALGO TIPO ASSIM:










->withMiddleware(
    function (Middleware $middleware) {


        $middleware->alias(
            [

            ]
        )
    }
)








DENTRO DE 'alias([])',


VC PASSA 1 LISTA DE ALIAS E OS MIDDLEWARES CORRESPONDENTES...




TIPO ASSIM:







->withMiddleware(
    function (Middleware $middleware) {


        $middleware->alias(
            [
                'role' => CheckUserRole::class,
                'admin' => SomeAdminMiddleware::class
            ]
        )
    }
)













COM ISSO, LÁ EM 'web.php',




DEVEMOS SIMPLESMENTE REFERENCIAR ISSO 


NO NOSSO 'Route::middleware()',


TIPO ASSIM:



Route::middleware('role')->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);


















OK... MAS COMO PODEMOS RECEBER PARAMETERS, DE DENTRO DE NOSSOS 
    MIDDLEWARES?







PODEMOS FAZER TIPO ASSIM (receber o argument de '$role', dentro do middleware):







<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

// Basic check for user authorization in your app.
class CheckUserRole
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next, string $userRole): Response
    {
        dump('Checking user role: ' . $userRole);

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];

        if ($user['role'] === 'admin') {
            return $next($request);
        }

        abort(404, 'This page does not exist.'); // * this is essentially the same as a throw new NotFoundHttpException(404, 'This page does not exist.')
    }
}
















--> AÍ, LÁ DENTRO DO 



'web.php',

para passar esse param,


podemos 



SIMPLESMENTE ESCREVER ASSIM:



Route::middleware('role:admin')->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);













--> com isso, conseguimos passar 1 value de 'admin' 
para dentro do middleware de 'CheckUserRole'...





--> a partir disso, podemos passar DIFERENTES VALUES,

COMO 



'role:editor',

'role:admin',

'role:user',











PODEMOS EDITAR NOSSO GUARD, TAMBÉM,


PARA QUE FUNCIONE ASSIM:







// Basic check for user authorization in your app.
class CheckUserRole
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next, string $role): Response
    {
        dump('Checking user role: ' . $role);

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];

        if ($user['role'] === $role) {
            return $next($request);
        }

        abort(404, 'This page does not exist.'); 
    }
}











COM ISSO, NOSSO MIDDLEWARE FICA MAIS FLEXÍVEL, PQ AGORA ELE __ SÓ VAI 
ACEITAR 


requests que tenham o parameter de 'role' como sendo de value 'admin',


conforme fora definido AQUI:



Route::middleware('role:admin')->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);





ELE FICA MAIS FLEXÍVEL PQ PODERÍAMOS COLOCAR OUTRA COISA 

NESSE MIDDLEWARE, COMO 'role:editor',

tipo assim:




Route::middleware('role:editor')->group(
    function () {
        Route::get('/', function () {
            return 'Some Secret Admin Page';
        });
        Route::get('/other', function () {
            return 'Another Secret Admin Page';
        });
    }
);




aí todos os requests que não tiverem o value de 'role' como sendo 'editor'

serão BARRADOS,

por conta deste código:







    public function handle(Request $request, Closure $next, string $role): Response
    {
        dump('Checking user role: ' . $role);

        $user = ['id' => 123, 'name' => 'Gio', 'role' => 'admin'];

        if ($user['role'] === $role) {
            return $next($request);
        }

        abort(404, 'This page does not exist.'); 
    }











COMO VC PODE PERCEBER, O LARAVEL É BEM FLEXÍVEL...








-> O LARAVEL TAMBÉM JÁ PROVIDENCIA UM MONTE DE MIDDLEWARES ÚTEIS,
    E JÁ TEM ELES ALIASED PARA NOSSA CONVENIÊNCIA...



    EX DE MIDDLEWARES JÁ ALIASED, DO LARAVEL:


    1) 'auth' ---> o mais comum 

    2) 'can' ---> AUTORIZA AÇÕES, COM BASE NAS ABILIDADES DE 1 USER... ('checks if the authenticated user has the given ability/permission')...









PARA ENCONTRAR A LISTA DE DEFAULT ALIASES DO 
LARAVEL,

BASTA ENTRAR EM 'Middleware.php' 

E PROCURAR POR 

'defaultAliases()',


TIPO ASSIM:






     */
    protected function defaultAliases()
    {
        $aliases = [
            'auth' => \Illuminate\Auth\Middleware\Authenticate::class,
            'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
            'auth.session' => \Illuminate\Session\Middleware\AuthenticateSession::class,
            'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
            'can' => \Illuminate\Auth\Middleware\Authorize::class,
            'guest' => \Illuminate\Auth\Middleware\RedirectIfAuthenticated::class,
            'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
            'precognitive' => \Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
            'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
            'throttle' => $this->throttleWithRedis
                ? \Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class
                : \Illuminate\Routing\Middleware\ThrottleRequests::class,
            'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        ];

        if (class_exists(\Spark\Http\Middleware\VerifyBillableIsSubscribed::class)) {
            $aliases['subscribed'] = \Spark\Http\Middleware\VerifyBillableIsSubscribed::class;
        }

        return $aliases;
    }








como vc pode ver,


são alguns...




VC PODE PASSAR CUSTOM ALIASES,

COMO VISTO ANTERIORMENTE,

E AÍ ELES SÃO 'MERGED TOGETHER',

NESSA LISTA AÍ...








LARAVEL É BEM FLEXÍVEL, PORTANTO, E OFERECE

BASTANTES MANEIRAS DE CONFIGURAR E CUSTOMIZAR O FRAMEWORK 
PARA QUE SE ENCAIXE A SEUS NEEDS... HÁ MÚLTIPLAS MANEIRAS DE FAZER 
AS COISAS,

NÃO HÁ 1 ÚNICA MANEIRA CERTA...







PODEMOS CHECAR OS DOCS DOS MIDDLEWARES, PARA TER MAIS INFO...














--> VC PODE DEFINIR MIDDLEWARES EM ROUTES,

    MAS TAMBÉM É POSSÍVEL FAZER ISSO NOS PRÓPRIOS CONTROLLERS,


    COM A INTERFACE DE 
    'hasMiddleware()'... 







--> DIGAMOS QUE QUEREMOS DEFINIR ALGUM TIPO DE 
    MIDDLEWARE PARA 

    O CONTROLLER DE 'TransactionController'...






SE VC QUISER FAZER ISSO, VC PRECISA 

DEFINIR O STATIC METHOD 'middleware()',

 no interior do controller,

 tipo assim:









 <?php

namespace App\Http\Controllers;

use App\Models\Transaction;
use Illuminate\Http\Request;

class TransactionController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(Request $request)
    {
        echo $request->headers->get('X-Request-Id'); // this will return the value of the header 'X-Request-Id'
        echo route('transactions.home') . '<br />'; // this will return the built url for the route 'transactions.home', in this case, 'localhost/transactions'

        echo route('transaction', ['transactionId' => 55]) . '<br />'; // this will return the built url for the route 'transactions.show', in this case, 'localhost/transactions/55'


        // * THIS WILL REDIRECT THE USER to the specified named route.
        to_route('transactions.create'); // this will return the built url for the route 'transactions.home', in this case, 'localhost/transactions'



        return view('transactions.index');
    }

    /**
     * Display the specified resource.
     */
    public function show(string $transactionId): string
    {
        return 'Transaction ' . $transactionId;
    }

    // public function show(Transaction $transaction)
    // {
    //     return 'Transaction ' . $transaction->id;
    // }

    /**
     * Show the form for creating a new resource.
     */
    public function create(): string
    {
        return 'Form to create a transaction';
    }


    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request): string
    {
        return 'Transaction Created';
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Transaction $transaction)
    {
        //
    }


    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Transaction $transaction)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Transaction $transaction)
    {
        //
    }

    public static function middleware()
    {
        return [

        ]
    }
}



















ESSE STATIC METHOD DEVERÁ RETORNAR 1 ARRAY, QUE SERÁ 

A LIST DE MIDDLEWARES...  AÍ VC PASSA A CLASSNAME DO MIDDLEWARE,

OU O ALIAS DO MIDDLEWARE... VC TAMBÉM PODE PASSAR 1 CLOSURE,

SE VC QUER DEFINIR O MIDDLEWARE DIRETAMENTE ALI,
EM VEZ DE 

DEFINIR EM 1 CLASS EXTERNA...






O PROFESSOR NÃO GOSTA DE DEFINIR MIDDLEWARES EM CONTROLLERS,

O PROFESSOR PREFERE DEFINIR EM ROUTES, MAS É POSSÍVEL...


